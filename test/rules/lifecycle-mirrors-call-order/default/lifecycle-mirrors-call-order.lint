import { Component, Prop } from '@stencil/core';

// Pass: No lifecycle hooks
@Component({
    tag: 'my-element-a'
})
export class ElementA {
    someFunction() { }
}

// Pass: One lifecycle hook
@Component({
    tag: 'my-element-b'
})
export class ElementB {
    componentWillLoad() { }
}

// Pass: All lifecycle hooks in order
@Component({
    tag: 'my-element-c'
})
export class ElementC {
  componentWillLoad() { }
  componentDidLoad() { }
  componentWillUpdate() { }
  componentDidUpdate() { }
  componentDidUnload() { }
}

// Fail 4/5: lifecycle hooks in reverse order
@Component({
    tag: 'my-element-d'
})
export class ElementD {
    @Prop() propA: string;
    @Prop() propB: string;
    @Prop() propC: string;

    componentDidUnload() { }
    ~~~~~~~~~~~~~~~~~~ [failure]
    componentDidUpdate() { }
    ~~~~~~~~~~~~~~~~~~ [failure]
    componentWillUpdate() { }
    ~~~~~~~~~~~~~~~~~~~ [failure]
    componentDidLoad() { }
    ~~~~~~~~~~~~~~~~ [failure]
    componentWillLoad() { }
    ~~~~~~~~~~~~~~~~~ [failure]

    hostData() { }
    render() { }
}

// Fail 2/2: lifecycle hooks out of order
@Component({
    tag: 'my-element-e'
})
export class ElementE {
  componentDidUnload() { }
  ~~~~~~~~~~~~~~~~~~ [failure]
  componentDidLoad() { }
  ~~~~~~~~~~~~~~~~ [failure]
}

// Fail 2/5: final lifecycle hooks flipped
@Component({
    tag: 'my-element-F'
})
export class ElementF {
    @Prop() propA: string;
    @Prop() propB: string;
    @Prop() propC: string;

    componentWillLoad() { }
    componentDidLoad() { }
    componentWillUpdate() { }
    componentDidUnload() { }
    ~~~~~~~~~~~~~~~~~~ [failure]
    componentDidUpdate() { }
    ~~~~~~~~~~~~~~~~~~ [failure]

    render() { }
}

// Pass: 3 lifecycle hooks in order
@Component({
    tag: 'my-element-z'
})
export class ElementZ {
  componentWillLoad() { }
  componentWillUpdate() { }
  componentDidUnload() { }
}

[failure]: Component lifecycle methods should be ordered according to their call order
